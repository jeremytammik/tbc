<p><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="bc.css"></p>
<!-- https://highlightjs.org/#usage
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
-->

<!-- https://prismjs.com -->
<p><link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css" rel="stylesheet" /></p>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<style> code[class*=language-], pre[class*=language-] { font-size : 90%; } </style>

</style>
<p></head></p>
<!---

- multi-version
  https://forums.autodesk.com/t5/revit-api-forum/optimal-add-in-code-base-approach-to-target-multiple-revit/m-p/12982599#M81063

twitter:

 the @AutodeskRevit #RevitAPI #BIM @DynamoBIM

&ndash; ...

linkedin:

#BIM #DynamoBIM #AutodeskAPS #Revit #API #IFC #SDK #Autodesk #AEC #adsk

the [Revit API discussion forum](http://forums.autodesk.com/t5/revit-api-forum/bd-p/160) thread

<center>
<img src="img/" alt="" title="" width="600"/>
<p style="font-size: 80%; font-style:italic"></p>
</center>

-->

<h3>Multi-Version Add-In Code Base</h3>
<p>Let's look at two current and recurring topics from
the <a href="http://forums.autodesk.com/t5/revit-api-forum/bd-p/160">Revit API discussion forum</a>:</p>
<ul>
<li><a href="#2">Multi-version add-in code base</a></li>
<li><a href="#3">UIView for element visibility</a></li>
</ul>
<h4><a name="2"></a> Multi-Version Add-In Code Base</h4>
<p>Managing an add-in code base to support multiple releases of the Revit API is a recurring and constantly evolving issue.
In 2021, we discussed how to implement
a <a href="https://thebuildingcoder.typepad.com/blog/2021/10/dll-as-resource-and-multi-version-add-ins.html#4">multi-version Revit add-in</a>,
and in 2023 <a href="https://thebuildingcoder.typepad.com/blog/2023/11/net-core-preview-and-open-source-add-in-projects.html#8">managing multiple Revit API versions</a></p>
<p>The issue was raised again half a year ago in preparation of the non-trivial migration for Revit 2025 from .NET 4.8 to .NET core, in a quest for
an <a href="https://forums.autodesk.com/t5/revit-api-forum/optimal-add-in-code-base-approach-to-target-multiple-revit/m-p/12982599">optimal add-in code base approach to target multiple Revit releases</a>.</p>
<p>That query recently received some updated answers and solutions from
Roman <a href="https://t.me/nice3point">@Nice3point</a> Karpovich, aka Роман Карпович,
and Nathan <a href="https://forums.autodesk.com/t5/user/viewprofilepage/user-id/3671855">@SamBerk</a> Berkowitz.</p>
<p>Roman points out that <a href="https://github.com/Nice3point/RevitTemplates">RevitTemplates</a> provides
a <a href="https://github.com/Nice3point/RevitTemplates/wiki/Step%E2%80%90by%E2%80%90step-Guide">step-by step guide for Revit multiversion templates</a>:</p>
<blockquote>
<p>You will be able to create a project in a few steps without spending hours setting up a solution from scratch. Try it.</p>
</blockquote>
<p>Sam's simpler approach provides less coverage, saying:</p>
<p>I found that the <em>simplest</em> solution to maintain the same code base for 2025 and earlier is to put the <code>TargetFramework</code> in a condition.
Here is step by step:</p>
<ul>
<li>Create a dotnet 8 class library project</li>
<li>Reference the Revit 2025 API DLL's RevitAPI.dll and RevitAPIUI.dll, set <code>Copy Local</code> to <code>No</code></li>
<li>Create configurations <code>2024Debug</code> and <code>2025Debug</code> (or release)</li>
<li>Edit the project file and put the <code>TargetFramework</code> and the <code>Reference</code> in a condition:</li>
</ul>
<pre><code class="language-xml"> &lt;PropertyGroup Condition="'$(Configuration)' == '2024Debug'"&gt;
   &lt;TargetFramework&gt;net481&lt;/TargetFramework&gt;
 &lt;/PropertyGroup&gt;
 &lt;PropertyGroup Condition="'$(Configuration)' == '2025Debug'"&gt;
   &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
 &lt;/PropertyGroup&gt;

 &lt;ItemGroup&gt;
    &lt;Reference Include="RevitAPI" Condition="'$(Configuration)' == '2024Debug'"&gt;
     &lt;HintPath&gt;..\..\..\..\..\..\..\..\Program Files\Autodesk\Revit 2024\RevitAPI.dll&lt;/HintPath&gt;
     &lt;Private&gt;False&lt;/Private&gt;
   &lt;/Reference&gt;
   &lt;Reference Include="RevitAPIUI" Condition="'$(Configuration)' == '2024Debug'"&gt;
     &lt;HintPath&gt;..\..\..\..\..\..\..\..\Program Files\Autodesk\Revit 2024\RevitAPIUI.dll&lt;/HintPath&gt;
     &lt;Private&gt;False&lt;/Private&gt;
   &lt;/Reference&gt;
   &lt;Reference Include="RevitAPI" Condition="'$(Configuration)' == '2025Debug'"&gt;
     &lt;HintPath&gt;..\..\..\..\..\..\..\..\Program Files\Autodesk\Revit 2025\RevitAPI.dll&lt;/HintPath&gt;
     &lt;Private&gt;False&lt;/Private&gt;
   &lt;/Reference&gt;
   &lt;Reference Include="RevitAPIUI" Condition="'$(Configuration)' == '2025Debug'"&gt;
     &lt;HintPath&gt;..\..\..\..\..\..\..\..\Program Files\Autodesk\Revit 2025\RevitAPIUI.dll&lt;/HintPath&gt;
     &lt;Private&gt;False&lt;/Private&gt;
   &lt;/Reference&gt;
 &lt;/ItemGroup&gt;</code></pre>

<p>Create an App.cs file and implement IExternalApplication</p>
<pre><code class="language-cs">public class App : IExternalApplication
{
  public Result OnStartup( UIControlledApplication a )
  {
    TaskDialog.Show( "Multi-Version Addin",
      $"Revit version: {a.ControlledApplication.VersionNumber}");

    return Result.Succeeded;
  }

  public Result OnShutdown( UIControlledApplication a )
  {
    return Result.Succeeded;
  }
}</code></pre>

<ul>
<li>Create an output folder for both versions (<em>C:/.../output/2024</em> and <em>C:/.../output/2025</em>)</li>
<li>Add a <code>.addin</code> file to your project for both versions (<code>MyAddin2024.addin</code> and <code>MyAddin2025.addin</code>)</li>
</ul>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RevitAddIns&gt;
  &lt;AddIn Type="Application"&gt;
    &lt;Name&gt;MyAddin&lt;/Name&gt;
    &lt;Assembly&gt;C:\...\output\2024\MyAddin.dll&lt;/Assembly&gt; (or 2025)
    &lt;FullClassName&gt;MyAddin.App&lt;/FullClassName&gt;
    &lt;ClientId&gt;{client id}&lt;/ClientId&gt;
    &lt;VendorId&gt;{vendor id}&lt;/VendorId&gt;
    &lt;VendorDescription&gt;{vendor description}&lt;/VendorDescription&gt;
  &lt;/AddIn&gt;
&lt;/RevitAddIns&gt;</code></pre>

<ul>
<li>Post-build events:</li>
</ul>
<pre><code class="language-cs">      echo Configuration: $(Configuration)
      if $(Configuration) == 2024Debug goto 2024
      if $(Configuration) == 2025Debug goto 2025

      :2024
      echo Copying results to 2024
      copy "$(ProjectDir)MyAddin2024.addin" "$(AppData)\Autodesk\REVIT\Addins\2024"
      copy "$(ProjectDir)bin\$(Configuration)\net481\*.dll" "C:\...\output\2024"
      goto exit

      :2024
      echo Copying results to 2024
      copy "$(ProjectDir)MyAddin2025.addin" "$(AppData)\Autodesk\REVIT\Addins\2025"
      copy "$(ProjectDir)bin\$(Configuration)\net8.0\*.dll" "C:\...\output\2025"
      goto exit

      :exit</code></pre>

<ul>
<li>Build both configurations</li>
<li>Open Revit 2024:</li>
</ul>
<p><center>
  <img src="img/multiversion_2024.png" alt="Multi-verxsion add-in" title="Multi-verxsion add-in" width="450"/>
</center></p>
<ul>
<li>Open Revit 2025:</li>
</ul>
<p><center>
  <img src="img/multiversion_2025.png" alt="Multi-verxsion add-in" title="Multi-verxsion add-in" width="450"/>
</center></p>
<ul>
<li>For debugging, add to the project file:</li>
</ul>
<pre><code class="language-xml">  &lt;PropertyGroup Condition="'$(Configuration)' == '2024Debug'"&gt;
    &lt;StartProgram&gt;C:\Program Files\Autodesk\Revit 2024\Revit.exe&lt;/StartProgram&gt;
    &lt;StartAction&gt;Program&lt;/StartAction&gt;
  &lt;/PropertyGroup&gt;

  &lt;PropertyGroup Condition="'$(Configuration)' == '2025Debug'"&gt;
    &lt;StartProgram&gt;C:\Program Files\Autodesk\Revit 2025\Revit.exe&lt;/StartProgram&gt;
    &lt;StartAction&gt;Program&lt;/StartAction&gt;
  &lt;/PropertyGroup&gt;</code></pre>

<p>Thank you all!</p>
<h4><a name="3"></a> UIView for Element Visibility</h4>
<p>Fabio Loretti <a href="https://forums.autodesk.com/t5/user/viewprofilepage/user-id/5076730">@floretti</a> Oliveira
determined how to <a href="https://forums.autodesk.com/t5/revit-api-forum/select-all-quot-ui-visible-quot-instances/td-p/12995081">select all UI visible family instances</a>:</p>
<p><strong>Question:</strong>
One of my users came up with an interesting question of whether or not it's possible to create a "Select All Instances &gt; Visible in View" command taking into consideration the view's zoom level, meaning that everything outside the user's field of view is "not visible" and it wouldn't be part of the selection.</p>
<p>I've tried to find references in the API and online articles on the below topics and ran some UI tests and compared values via the Revit Lookup but no success.</p>
<ul>
<li>Active view zoom level</li>
<li>Active view window size</li>
<li>Bounding boxes XYZ and UV and whether they change under different zoom levels</li>
</ul>
<p><strong>Answer:</strong>
The first thing to try out is
the <a href="https://www.revitapidocs.com/2024/6359776d-915e-f8a2-4147-b31024671ee1.htm">filtered element collector taking a view element id</a>.</p>
<p>The description says, <em>Constructs a new FilteredElementCollector that will search and filter the visible elements in a view</em>, which exactly matches your query. I would be surprised if the two exactly matching descriptions really mean exactly the same thing, but who knows, you may be in luck.</p>
<p><strong>Response:</strong>
Unfortunately, that overload of the FilteredElementCollector doesn't do what I'm after.
The definition of "visible" to the API is different to the definition of what a user considers visible.
The example below shows what I mean.</p>
<p>View B shows 8x wall elements.
If I decrease the size of a view/window or simply zoom in or pan I won't be able to see all the 8x walls anymore like shown on View A.
Regardless of whether or not I use the <code>FilteredElementCollector</code> and pass the view Id as a 2nd parameter or use the UI command <em>Select All Instances</em> &gt; <em>Visible in View</em>, Revit will select all 8x wall instances.</p>
<p><center>
  <img src="img/elem_visible_1.png" alt="Elements visible in view" title="Elements visible in view" width="500"/>
</center></p>
<p><strong>Answer:</strong>
Does the article
on <a href="https://thebuildingcoder.typepad.com/blog/2017/05/retrieving-elements-visible-in-view.html">retrieving elements visible in view</a> help?</p>
<p><strong>Response:</strong>
I tested that approach and these are the results.</p>
<p>This is View A showing all 8x wall instances and its <code>ViewPlan.CropBox</code> values underneath as recommended by the article:</p>
<p><center>
  <img src="img/elem_visible_2.png" alt="Elements visible in view" title="Elements visible in view" width="500"/>
</center></p>
<p>I then panned across View A so only 4x wall instances are shown in the UI and again the <code>ViewPlan.CropBox</code> values underneath.</p>
<p><center>
  <img src="img/elem_visible_3.png" alt="Elements visible in view" title="Elements visible in view" width="500"/>
</center></p>
<p>Notice that the values didn't change; based on that, I do not expect the outcome to be different if I turn this into code. I noticed that the API has two Boolean properties to indicate whether the <code>CropBox</code> is either active and visible; in my case, neither of them are true.
Based on that, my assumption is that the recommended approach in the article you shared can only work via the cropbox use and not by zooming in/out and panning across a view.</p>
<p><center>
  <img src="img/elem_visible_4.png" alt="Elements visible in view" title="Elements visible in view" width="500"/>
</center></p>
<p><strong>Answer:</strong>
OK, I see that the crop box approach does not help in this case.
Searching the forum, I found these two specific solutions for other situations:</p>
<ul>
<li><a href="https://forums.autodesk.com/t5/revit-api-forum/how-to-list-only-elements-that-are-quot-visible-quot-in-a-view/m-p/10663861">How to list only elements that are "Visible" in a view</a></li>
<li><a href="https://forums.autodesk.com/t5/revit-api-forum/selection-filter-for-only-what-is-visible-from-camera/m-p/12534209">Selection filter for only what is visible from camera</a></li>
</ul>
<p>In your case, maybe
the <a href="https://www.revitapidocs.com/2024/2a070256-00f0-5cab-1412-bee5bbfcfc5e.htm"><code>UIView</code></a> can help:</p>
<p>The <code>View</code> element is part of the document and lives in the database.
It maybe does not know how it is currently being "looked at".
The <code>UIView</code> may know that and provides the current zoom corners from which you can determine whether an element is currently within them or not.
However, for non-planar views, you will have some interesting calculations to perform.</p>
<p>I used the <code>UIView</code> to implement
a <a href="https://thebuildingcoder.typepad.com/blog/2012/10/uiview-windows-coordinates-referenceintersector-and-my-own-tooltip.html">tooltip that detects which elements are visible under the cursor</a>.
It also uses the <code>ReferenceIntersector</code>, like one of the solutions I pointed out above.</p>
<p><strong>Response:</strong>
Amazing, thanks Jeremy.
The <code>GetZoomCorners</code> method is exactly what I need.
Much appreciated.
:-)</p>
<p>Just giving back, here is the solution I implemented.</p>
<p>Note this code searches for a specific <code>familyName</code> and <code>familyType</code>, so it works with family instances and it won't work with system families:</p>
<pre><code class="language-cs">// Get active view's zoom corners
var zc = new List&lt;XYZ&gt;();

var openUIviews = uidoc.GetOpenUIViews();
foreach (var uiView in openUIviews)
{
  if(uiView.ViewId == doc.ActiveView.Id)
    zc = uiView.GetZoomCorners().ToList();
}

// Get selection and expand it
var selIds = uidoc.Selection.GetElementIds();
var finalSelectionIds = new List&lt;ElementId&gt;();

foreach (ElementId id in selIds)
{
  Outline viewExtents = new Outline(
    new XYZ(zc.First().X, zc.First().Y, -1000),
    new XYZ(zc.Last().X, zc.Last().Y, 1000));

  var filter = new BoundingBoxIntersectsFilter(viewExtents);

  var famInst = doc.GetElement(id) as FamilyInstance;
  var allFamInst
    = new FilteredElementCollector(doc, doc.ActiveView.Id)
      .WherePasses(filter)
      .OfClass(typeof(FamilyInstance))
      .Cast&lt;FamilyInstance&gt;()
      .Where(x =&gt; x.Symbol.Family.Name.Equals(familyName)) // family
      .Where(x =&gt; x.Name.Equals(familyType)); // family type

  foreach (FamilyInstance item in allFamInst)
  {
    finalSelectionIds.Add(item.Id);
  }
}

uidoc.Selection.SetElementIds(finalSelectionIds);</code></pre>

<p>Many thanks to Fabio for testing, confirming and sharing this solution.</p>